
    <!DOCTYPE html>
    <html lang="en">
        <head>
        <title>C++ std::async with a concurrency limit (via semaphores) - Raymii.org</title>
        <style> *, ::before, ::after {background-repeat: no-repeat;-webkit-box-sizing: border-box;box-sizing: border-box;}::before, ::after {text-decoration: inherit;vertical-align: inherit;}html {cursor: default;font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height: 1.15;-moz-tab-size: 4;-o-tab-size: 4;tab-size: 4;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%;word-break: break-word;}body {background-color: white;margin: 0;}h1 {font-size: 2em;margin: 0.67em 0;}hr {height: 0;overflow: visible;}main {display: block;}nav ol, nav ul {list-style: none;}pre {font-family: Roboto Mono, Menlo, Consolas, Ubuntu Monospace, Noto Mono, Oxygen Mono, Liberation Mono, monospace;font-size: 1em;}a {background-color: transparent;}abbr[title] {text-decoration: underline;-webkit-text-decoration: underline dotted;text-decoration: underline dotted;}b, strong {font-weight: bolder;}code, kbd, samp {font-family: Menlo, Consolas, Roboto Mono, Ubuntu Monospace, Noto Mono, Oxygen Mono, Liberation Mono, monospace;font-size: 1em;}small {font-size: 80%;}::-moz-selection {background-color: #b3d4fc;color: #000;text-shadow: none;}::selection {background-color: #b3d4fc;color: #000;text-shadow: none;}audio, canvas, iframe, img, svg, video {vertical-align: middle;}audio, video {display: inline-block;}audio:not([controls]) {display: none;height: 0;}img {border-style: none;}svg:not([fill]) {fill: currentColor;}svg:not(:root) {overflow: hidden;}table {border-collapse: collapse;}button, input, select, textarea {font-family: inherit;font-size: inherit;line-height: inherit;}button, input, select {margin: 0;}button {overflow: visible;text-transform: none;}button, [type="button"], [type="reset"], [type="submit"] {-webkit-appearance: button;}fieldset {padding: 0.35em 0.75em 0.625em;}input {overflow: visible;}legend {color: inherit;display: table;max-width: 100%;white-space: normal;}progress {display: inline-block;vertical-align: baseline;}select {text-transform: none;}textarea {margin: 0;overflow: auto;resize: vertical;}[type="checkbox"], [type="radio"] {padding: 0;}[type="search"] {-webkit-appearance: textfield;outline-offset: -2px;}::-webkit-inner-spin-button, ::-webkit-outer-spin-button {height: auto;}::-webkit-input-placeholder {color: inherit;opacity: 0.54;}::-webkit-search-decoration {-webkit-appearance: none;}::-webkit-file-upload-button {-webkit-appearance: button;font: inherit;}::-moz-focus-inner {border-style: none;padding: 0;}:-moz-focusring {outline: 1px dotted ButtonText;}details {display: block;}dialog {background-color: white;border: solid;color: black;display: block;height: -moz-fit-content;height: -webkit-fit-content;height: fit-content;left: 0;margin: auto;padding: 1em;position: absolute;right: 0;width: -moz-fit-content;width: -webkit-fit-content;width: fit-content;}dialog:not([open]) {display: none;}summary {display: list-item;}canvas {display: inline-block;}template {display: none;}a, area, button, input, label, select, summary, textarea, [tabindex] {-ms-touch-action: manipulation;touch-action: manipulation;}[hidden] {display: none;}[aria-busy="true"] {cursor: progress;}[aria-controls] {cursor: pointer;}[aria-disabled="true"], [disabled] {cursor: not-allowed;}[aria-hidden="false"][hidden]:not(:focus) {clip: rect(0, 0, 0, 0);display: inherit;position: absolute;}main, header, footer, article, section, aside, details, summary {margin: 0 auto;margin-bottom: 16px;width: 100%;}main {display: block;margin: 0 auto;max-width: 1000px;padding: 0 16px 16px;}footer {border-top: 1px solid rgba(0, 0, 0, 0.12);padding: 16px 0;text-align: left;}footer p {margin-bottom: 0;}hr {border: 0;border-top: 1px solid rgba(0, 0, 0, 0.12);display: block;margin-top: 16px;margin-bottom: 16px;width: 100%;-webkit-box-sizing: content-box;box-sizing: content-box;height: 0;overflow: visible;}img {height: auto;max-width: 100%;vertical-align: baseline;}@media screen and (max-width: 400px) {article, section, aside {clear: both;display: block;max-width: 100%;}img {margin-right: 16px;}}embed, iframe, video {border: 0;}body {color: rgba(0, 0, 0, 0.8);font-family: "Ubuntu", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";font-size: 16px;line-height: 1.5;}p {margin: 0;margin-bottom: 16px;}h1, h2, h3, h4, h5, h6 {color: inherit;font-family: inherit;line-height: 1.2;font-weight: 500;}h1 {font-size: 40px;margin: 20px 0 16px;}h2 {font-size: 32px;margin: 20px 0 16px;}h3 {color: #75cc00;font-size: 28px;margin: 16px 0 4px;}h4 {color: #75cc00;font-size: 24px;margin: 16px 0 4px;}h5 {color: #75cc00;font-size: 20px;margin: 16px 0 4px;}h6 {color: #75cc00;font-size: 16px;margin: 16px 0 4px;}small {color: rgba(0, 0, 0, 0.54);vertical-align: bottom;}pre {background: #f7f7f9;color: rgba(0, 0, 0, 0.8);display: block;font-family: "Roboto Mono", Menlo, Monaco, Consolas, "Courier New", monospace;font-size: 16px;margin: 16px 0;padding: 16px;white-space: pre-wrap;overflow-wrap: break-word;}code {background: #f7f7f9;color: rgba(0, 0, 0, 0.8);font-family: "Roboto Mono", Menlo, Monaco, Consolas, "Courier New", monospace;font-size: 16px;line-height: inherit;margin: 0;vertical-align: baseline;word-break: break-all;word-wrap: break-word;}a {color: #75cc00;text-decoration: none;background-color: transparent;}a:hover, a:focus {color: #0062cc;font-weight: bolder;text-decoration: underline;}dl {margin-bottom: 16px;}dd {margin-left: 40px;}ul, ol {margin-bottom: 8px;padding-left: 40px;vertical-align: baseline;}blockquote {border-left: 2px solid rgba(0, 0, 0, 0.8);font-family: Georgia, Times, "Times New Roman", serif;font-style: italic;margin: 16px 0;padding-left: 16px;}figcaption {font-family: Georgia, Times, "Times New Roman", serif;}u {text-decoration: underline;}s {text-decoration: line-through;}sup {font-size: 14px;vertical-align: super;}sub {font-size: 14px;vertical-align: sub;}mark {background: #ffeb3b;}input[type="text"], input[type="password"], input[type="email"], input[type="url"], input[type="date"], input[type="month"], input[type="time"], input[type="datetime"], input[type="datetime-local"], input[type="week"], input[type="number"], input[type="search"], input[type="tel"], select, textarea {background: #fff;background-clip: padding-box;border: 1px solid rgba(0, 0, 0, 0.12);border-radius: 4px;color: rgba(0, 0, 0, 0.8);display: block;width: 100%;padding: 8px 16px;line-height: 1.5;-webkit-transition: border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";}input[type="color"] {background: #fff;border: 1px solid rgba(0, 0, 0, 0.12);border-radius: 4px;display: inline-block;vertical-align: middle;}input:not([type]) {-webkit-appearance: none;background: #fff;background-clip: padding-box;border: 1px solid rgba(0, 0, 0, 0.12);border-radius: 4px;color: rgba(0, 0, 0, 0.8);display: block;width: 100%;padding: 8px 16px;line-height: 1.5;-webkit-transition: border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out;transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;text-align: left;}input[type="text"]:focus, input[type="password"]:focus, input[type="email"]:focus, input[type="url"]:focus, input[type="date"]:focus, input[type="month"]:focus, input[type="time"]:focus, input[type="datetime"]:focus, input[type="datetime-local"]:focus, input[type="week"]:focus, input[type="number"]:focus, input[type="search"]:focus, input[type="tel"]:focus, input[type="color"]:focus, select:focus, textarea:focus {background-color: #fff;border-color: #80bdff;outline: 0;-webkit-box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);}input:not([type]):focus {background-color: #fff;border-color: #80bdff;outline: 0;-webkit-box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);}input[type="file"]:focus, input[type="radio"]:focus, input[type="checkbox"]:focus {outline: 1px thin rgba(0, 0, 0, 0.12);}input[type="text"][disabled], input[type="password"][disabled], input[type="email"][disabled], input[type="url"][disabled], input[type="date"][disabled], input[type="month"][disabled], input[type="time"][disabled], input[type="datetime"][disabled], input[type="datetime-local"][disabled], input[type="week"][disabled], input[type="number"][disabled], input[type="search"][disabled], input[type="tel"][disabled], input[type="color"][disabled], select[disabled], textarea[disabled] {background-color: rgba(0, 0, 0, 0.12);color: rgba(0, 0, 0, 0.54);cursor: not-allowed;opacity: 1;}input:not([type])[disabled] {background-color: rgba(0, 0, 0, 0.12);color: rgba(0, 0, 0, 0.54);cursor: not-allowed;opacity: 1;}input[readonly], select[readonly], textarea[readonly] {border-color: rgba(0, 0, 0, 0.12);color: rgba(0, 0, 0, 0.54);}input:focus:invalid, textarea:focus:invalid, select:focus:invalid {border-color: #ea1c0d;color: #f44336;}input[type="file"]:focus:invalid:focus, input[type="radio"]:focus:invalid:focus, input[type="checkbox"]:focus:invalid:focus {outline-color: #f44336;}select {border: 1px solid rgba(0, 0, 0, 0.12);vertical-align: sub;}select:not([size]):not([multiple]) {height: -webkit-calc(2.25rem + 2px);height: calc(2.25rem + 2px);}select[multiple] {height: auto;}label {display: inline-block;line-height: 2;}fieldset {border: 0;margin: 0;padding: 8px 0;}legend {border-bottom: 1px solid rgba(0, 0, 0, 0.12);color: rgba(0, 0, 0, 0.8);display: block;margin-bottom: 8px;padding: 8px 0;width: 100%;}textarea {overflow: auto;resize: vertical;}input[type=checkbox], input[type=radio] {-webkit-box-sizing: border-box;box-sizing: border-box;padding: 0;display: inline;}input[type=submit], input[type=reset], input[type=button], button {background-color: #75cc00;border: #75cc00;border-radius: 4px;color: #fff;padding: 8px 16px;display: inline-block;font-weight: 400;text-align: center;white-space: nowrap;vertical-align: middle;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;border: 1px solid transparent;font-size: 1rem;line-height: 1.5;-webkit-transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out, -webkit-box-shadow .15s ease-in-out;}input[type=submit]::-moz-focus-inner, input[type=reset]::-moz-focus-inner, input[type=button]::-moz-focus-inner, button::-moz-focus-inner {padding: 0;}input[type=submit]:hover, input[type=reset]:hover, input[type=button]:hover, button:hover {background-color: #0069d9;border-color: #0062cc;color: #fff;}input[type=submit]:not(:disabled):active, input[type=reset]:not(:disabled):active, input[type=button]:not(:disabled):active, button:not(:disabled):active {background-color: #0062cc;border-color: #005cbf;color: #fff;}input[type=submit]:focus, input[type=reset]:focus, input[type=button]:focus, button:focus {outline: 0;-webkit-box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);}input[type=submit]:disabled, input[type=reset]:disabled, input[type=button]:disabled, button:disabled {opacity: .65;cursor: not-allowed;background-color: #75cc00;border-color: #75cc00;color: #fff;}table {border-top: 1px solid rgba(0, 0, 0, 0.12);margin-bottom: 16px;}caption {padding: 8px 0;}thead th {border: 0;border-bottom: 2px solid rgba(0, 0, 0, 0.12);text-align: left;}tr {margin-bottom: 8px;}th, td {border-bottom: 1px solid rgba(0, 0, 0, 0.12);padding: 16px;white-space: nowrap;vertical-align: inherit;}tfoot tr {text-align: left;}tfoot td {color: rgba(0, 0, 0, 0.54);font-size: 8px;font-style: italic;padding: 16px 4px;}a.skip-main {left:-999px;position:absolute;top:auto;width:1px;height:1px;overflow:hidden;z-index:-999;}a.skip-main:focus, a.skip-main:active {color: #fff;background-color:#000;left: auto;top: auto;width: 30%;height: auto;overflow:auto;margin: 10px 35%;padding:5px;border-radius: 15px;border:4px solid yellow;text-align:center;font-size:1.2em;z-index:999;}@font-face {font-family: 'Raleway';font-style: normal;font-weight: 600;src: url('/s/inc/css/raleway-v18-latin-600.eot');src: local(''), url('/s/inc/css/raleway-v18-latin-600.eot?#iefix') format('embedded-opentype'), url('/s/inc/css/raleway-v18-latin-600.woff2') format('woff2'), url('/s/inc/css/raleway-v18-latin-600.woff') format('woff'), url('/s/inc/css/raleway-v18-latin-600.ttf') format('truetype'), url('/s/inc/css/raleway-v18-latin-600.svg#Raleway') format('svg');}@font-face {font-family: 'Raleway';font-style: italic;font-weight: 400;src: url('/s/inc/css/raleway-v18-latin-italic.eot');src: local(''), url('/s/inc/css/raleway-v18-latin-italic.eot?#iefix') format('embedded-opentype'), url('/s/inc/css/raleway-v18-latin-italic.woff2') format('woff2'), url('/s/inc/css/raleway-v18-latin-italic.woff') format('woff'), url('/s/inc/css/raleway-v18-latin-italic.ttf') format('truetype'), url('/s/inc/css/raleway-v18-latin-italic.svg#Raleway') format('svg');}@font-face {font-family: 'Roboto Mono';font-style: normal;font-weight: 400;src: url('/s/inc/css/roboto-mono-v12-latin-regular.eot');src: local(''), url('/s/inc/css/roboto-mono-v12-latin-regular.eot?#iefix') format('embedded-opentype'), url('/s/inc/css/roboto-mono-v12-latin-regular.woff2') format('woff2'), url('/s/inc/css/roboto-mono-v12-latin-regular.woff') format('woff'), url('/s/inc/css/roboto-mono-v12-latin-regular.ttf') format('truetype'), url('/s/inc/css/roboto-mono-v12-latin-regular.svg#RobotoMono') format('svg');}@font-face {font-family: 'Roboto Mono';font-style: normal;font-weight: 600;src: url('/s/inc/css/roboto-mono-v12-latin-600.eot');src: local(''), url('/s/inc/css/roboto-mono-v12-latin-600.eot?#iefix') format('embedded-opentype'), url('/s/inc/css/roboto-mono-v12-latin-600.woff2') format('woff2'), url('/s/inc/css/roboto-mono-v12-latin-600.woff') format('woff'), url('/s/inc/css/roboto-mono-v12-latin-600.ttf') format('truetype'), url('/s/inc/css/roboto-mono-v12-latin-600.svg#RobotoMono') format('svg');}@font-face {font-family: 'Ubuntu';font-style: normal;font-weight: 400;src: url('/s/inc/css/ubuntu-v15-latin-regular.eot');src: local(''), url('/s/inc/css/ubuntu-v15-latin-regular.eot?#iefix') format('embedded-opentype'), url('/s/inc/css/ubuntu-v15-latin-regular.woff2') format('woff2'), url('/s/inc/css/ubuntu-v15-latin-regular.woff') format('woff'), url('/s/inc/css/ubuntu-v15-latin-regular.ttf') format('truetype'), url('/s/inc/css/ubuntu-v15-latin-regular.svg#Ubuntu') format('svg');}@font-face {font-family:'Raleway2';font-style:normal;font-weight:normal;src:url('/s/inc/css/raleway.eot');src:local('Raleway2'),local('Raleway2'),url('/s/inc/css/raleway.ttf') }.headheader {font-family:"Raleway2"!important }.headheader a {color:#000;text-decoration:none }.headheader a:hover {color:#000;text-decoration:none!important }#toc ul {list-style: none;margin: 0;padding: 0;}#toc h3 {color:black;}</style>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="application/opensearchdescription+xml" rel="search" href="/s/inc/opensearch.xml"/>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for Raymii.org" href="https://raymii.org/s/feed.xml" />         
    </head>
    <body>
        
        <a id="top-of-page"></a>
        <main>
        <a class="skip-main" href="#main">Skip to main content</a>
            <header>
                <h1 class="headheader">
                    <a href="https://raymii.org/s/">Raymii.org 
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAKCAYAAAD2Fg1xAAABgElEQVQ4jb3VP0iVYRTH8c9waXBokog7OYhTXChuF3GIi4hoiJA4REQIOTgGtoWTg6ODs0SYComIXCJEMhpKtD9guUU0ujRFS0PQ8DzC24v3Pq+3S9/pnMOP8/7Ocx6el/OziRN0JXTD+I2xhK4WdeNteGmbu8IgC3jQQlfCZ0zgINHzJabwoQP+ClHGV1zGJXwRDJ/FDJZi3MBQE10dL2K8gZFOGE3REDZyyjLunKG7KAzZHfMaXjXp+QbXYlzBfrvmSuhBNaHrxQU8zdQW8RhrOe0snuB7zA/jd6p4n9HV8QMfY/4JPzGAt7meFfS18LdXEk7uemIQuJ/Lj6PZQezFWhm3cTWnXcAj3MrU5oWh5WpzGM3UurGNZy28HSa8J7mB3Uy+4u/rl+UdrsT4Jraa6F6jP5M3MP0PHguzL9zzqmC2GRNYjXF2qDzDwgbgHp53wGMhJrEunGQ9oT3CQ+GFasWBsLVvwiv5XygJz/JOAe208POrJHST+CVspBB/AFY9Q3+QJqLxAAAAAElFTkSuQmCC" alt="Raymii.org Logo">
                    </a>
                </h1>
                <small>
                  Quis custodiet ipsos custodes?<br>
                  <a href="/s/">Home</a> | 
                  <a href="/s/static/About.html">About</a> | 
                  <a href="/s/tags/all.html">All pages</a> | 
                  <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                  <a href="https://raymii.org/s/feed.xml">RSS Feed</a> 
                </small><br/><p>
                <link href="/s/_pagefind/pagefind-ui.css" rel="stylesheet">
                <script src="/s/_pagefind/pagefind-ui.js" type="text/javascript"></script>
                <div id="search" style="min-width:400px;max-width:1080px;"></div>
                <script>
                    window.addEventListener('DOMContentLoaded', (event) => {
                        new PagefindUI({ element: "#search" });
                    });
                </script>
                </p>
            </header>
          
    <main data-pagefind-body><h2 class='headheader' data-pagefind-meta='title' id='main'>C++ std::async with a concurrency limit (via semaphores)</h2>
<p><small>Published: <span data-pagefind-meta='date'>09-01-2021</span> | Last update: 10-01-2021 | Author: Remy van Elst | <a href="Cpp_std_async_with_a_concurrency_limit.txt">Text only version of this article</a>
</small></p>
<br><div class='olderthanayear'><p><strong>&#10071; This post is over four years old. It may no longer be up to date. Opinions may have changed.</strong></p></div>
<div id="toc">
<h3>Table of Contents</h3>
<ul>
<li>
<a href="#toc_0">Mutexes and Semaphores</a>
</li>
<li>
<a href="#toc_1">Project setup</a>
</li>
<li>
<a href="#toc_2">Queue up jobs and wait until they&#39;re all finished</a>
</li>
<li>
<a href="#toc_3">Job queue with a concurrency limit</a>
</li>
<li>
<a href="#toc_4">C++ 17 with a scoped_lock</a>
<ul>
<li>
<a href="#toc_5">More comments from Chris</a>
</li>
</ul>
</li>
</ul>

</div><hr><div id="contents">
<p><img src="/s/inc/img/semafoor.jpeg" alt="Semafoor"></p>

<blockquote>
<p>Semafoor en Dommel</p>
</blockquote>

<p><code>std::async</code> is an easy way to do multiple things concurrently, without the
hurdle of manual thread management in C++. Like batch converting images,
database calls, http requests, you name it. Create a few <code>std::futures</code> and
later on when they&#39;re ready, <code>.get()</code> &#39;m while they&#39;re still hot. A <code>future</code>
is an object which handles the synchronization and guarantees that the results
of the invocation are ready. If you <code>.get()</code> it and it&#39;s not ready, it will block.</p>

<p>Recently I had a use case for concurrency with a limit. I needed to do hundreds
of <a href="/s/software/Cpp_exercise_in_parsing_json_http_apis_and_time_stuff.html">HTTP calls to a JSON API</a>. The concurrency limit was not for the hardware,
but for the server on the other side. I didn&#39;t want to hammer it with requests. 
But you can also imagine that you&#39;re converting images or other &quot;heavy&quot; processes 
which might be taxing for the hardware. If in doubt, always benchmark. </p>

<p><img src="/s/inc/img/cpp-async-4.png" alt="screenshot"></p>

<blockquote>
<p>The end result, async tasks with a concurrency limit</p>
</blockquote>

<p>There is no standard way to limit the amount of concurrent jobs via <code>std::async</code>. 
You can fire of a hundred jobs and it is up to the implementation to not fry the 
hardware. On linux/gcc it will probably use a thread pool so you&#39;re lucky, but
you cant assume that. </p>

<p>This article will show you a simple short solution to implement a concurrency
limit together with std::async, by using a <a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore</a>, implemented with 
modern (C++ 11) standard library features (<code>std::mutex</code>, <code>std::condition_variable</code> and such).
It also has a C++ 17 version which replaces our custom <code>CriticalSection</code>
class with the use of an <code>std::scoped_lock</code> and implementing the <code>BasicLockable</code>
Named Requirement.</p>

<p>We start off with a shorter example showing how to fire off a set number of jobs 
and wait until all of those are finished before continuing. That is very useful
if you have a set number of jobs and want the implementation to handle all the 
thread work for you.</p>

<p class="ad"> <b>Recently I removed all Google Ads from this site due to their invasive tracking, as well as Google Analytics. Please, if you found this content useful, consider a small donation using any of the options below. It means the world to me if you  show your appreciation and you'll help pay the server costs:</b><br><br> <a href="https://github.com/sponsors/RaymiiOrg/">GitHub Sponsorship</a><br><br> <a href="https://pcbway.com/g/e7yQRg">PCBWay referral link (You get $5, I get $20 after you've placed an order)</a><br><br> <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocea referral link  ($200 credit for 60 days. Spend $25 after your credit expires and I'll get $25!)</a><br><br> </p>

<p>I was introduced to <a href="https://www.youtube.com/watch?v=3ENV48XgxMU">Semafoor</a> in my childhood by the Dutch (Belgian)
cartoon <a href="https://en.wikipedia.org/wiki/Cubitus">Dommel</a>, or <code>Cubitus</code> in the USA. The series tells the story of
Cubitus, a good-natured large, white dog endowed with speech. He lives in a
house in the suburbs with his master, Semaphore, a retired sailor, next door
to Senechal, the black and white cat who is Cubitus&#39; nemesis. </p>

<p>If you need these &quot;advanced&quot; concurrency features you could also just resort to 
<a href="/s/articles/Cpp_async_threads_and_user_input.html">manual thread management</a>. However, that is quite a bit more work to pull
off and for simple use cases <code>std::async</code> is just easier and simpler to setup and 
use. This Semaphore adds a bit of complexity, but IMHO it&#39;s worth it, small enough
and still better than manual thread management.</p>

<h3 id="toc_0">Mutexes and Semaphores</h3>

<p>Mutexes (mutual exclusion) and semaphores are similar in use and are often
used interchangeably. I&#39;ll try to explain a the meaning in our C++ setup.</p>

<p>First a bit on what they share. Both a semaphore and a mutex are constructs
that blocks execution of threads under certain conditions. Most often they 
are used in a &quot;critical section&quot; of code, that can have only one (or only a few)
threads working on it at a time. </p>

<p>When a mutex or semaphore is available, a thread can acquire (lock) the mutex
or semaphore and continue executing the &quot;critical section&quot;.  </p>

<p>When a mutex or semaphore is not available (locked), a thread is blocked from
further execution when it wants to acquire/lock it.  Threads that have acquired a
mutex or semaphore must release it so another thread can (eventually) acquire
it again. If that does not happen or if threads are waiting on one another, there
is a deadlock.</p>

<p>The difference between a mutex and a semaphore is in our case that only one
thread at a time can acquire a mutex, but some preset number of threads can
concurrently acquire a semaphore. </p>

<p>A semaphore is used for flow control / signaling, (to restrict the number of
threads executing the critical section).</p>

<p>In our case, the semaphore has a limit of 4, so when 4 threads have acquired
the semaphore, new threads must wait (are blocked) until the semaphore is available
again (once one of the 4 releases it). The waiting is all handled by C++ language
constructs (<code>condititon_variable</code>, <code>lock_guard</code>)</p>

<p>By using <code>RAII</code>, we can create an object named <code>CriticalSection</code>, 
which acquires the semaphore when it is constructed (comes into scope) and 
releases it when it is destructed (goes out of scope). Very handy since that
way you can never forget to manually release the semaphore.</p>

<h3 id="toc_1">Project setup</h3>

<p>For this guide I assume you&#39;re running on a Linux system with <code>gcc</code> and <code>cmake</code>.
This is my <code>CMakeLists.txt</code> file:</p>

<pre><code>cmake_minimum_required(VERSION 3.10)
project(async-with-max-concurrency)
set(CMAKE_CXX_STANDARD 11)

find_package(Threads REQUIRED)
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} Threads::Threads)
</code></pre>

<p>Thank you to <a href="https://www.offtopica.uk/">Matthew Smith</a> for <a href="https://lobste.rs/s/do6zii/c_std_async_with_concurrency_limit_via#c_wlx10s">showing me</a> this over <code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot; )</code>. </p>

<p>Quoting the advantages:</p>

<blockquote>
<p>It&#39;s more portable (supports Win32 threads) and it will only set it for your
target, instead of for every target in your project.</p>
</blockquote>

<p>As always with cMake projects, create a build folder and configure cmake:</p>

<pre><code>mkdir build
cd build
cmake ..
</code></pre>

<p>If you are ready to build the project, do a <code>make</code> in that folder:</p>

<pre><code>make
</code></pre>

<p>The binary is located in the same build folder:</p>

<pre><code>./async-with-max-concurrency
</code></pre>

<h3 id="toc_2">Queue up jobs and wait until they&#39;re all finished</h3>

<p>This is a simpler example to get us started. Imagine yourself having to 
get 15 JSON API endpoints, <code>/api/v1/page/0.json</code> up to <code>14.json</code> to 
process that information. You could write a for loop, which is fine 
and simple. Doing 15 HTTP calls takes a few seconds, if one of them 
is slow, the entire gathering part is slower overall. Wouldn&#39;t it be 
nice if you could fetch those 15 pages at once? One slow page doesn&#39;t
slow the entire process down much. </p>

<p>Here is where <code>std::async</code> comes to the rescue. You create a bunch of 
<code>std::future</code> objects that do the actual work and fire them off. Once
they&#39;re all finished, you can proceed. </p>

<p>This example does not make use of a semaphore or locking, it just fires
off a set number of threads and lets the implementation manages </p>

<p>The code below fills a vector with <code>future</code> objects that return a 
string. It uses a special template function to check if the <code>futures</code>
are ready, and if so, puts the result in another vector. </p>

<p>You can only <code>.get()</code> a future once. If it&#39;s not ready, that call blocks. 
By using this template to check the state of the future, we ensure 
that it is ready when we do the <code>.get()</code>, not blocking our execution.</p>

<pre><code>// main.cpp
template&lt;typename T&gt;
bool isReady(const std::future&lt;T&gt;&amp; f) {
    if (f.valid()) { // otherwise you might get an exception (std::future_error: No associated state)
        return f.wait_for(std::chrono::seconds(0)) == std::future_status::ready;
    } else {
        return false;
    }
}

std::string timeString(std::chrono::system_clock::time_point t, const std::string&amp; format) {
    time_t timepoint_time_t = std::chrono::system_clock::to_time_t(t);
    char buffer[1024];
    struct tm tm {0};
    if (!gmtime_r(&amp;timepoint_time_t, &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    if (!std::strftime(buffer, sizeof(buffer), format.c_str(), &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    return std::string{buffer};
}

int main() {
    int totalJobs = 15;
    std::vector&lt;std::future&lt;std::string&gt;&gt; futures;
    std::vector&lt;std::string&gt; readyFutures;
    // Queue up all the items,
    for (int i = 0; i &lt; totalJobs; ++i) {
        futures.push_back(
            std::async(std::launch::async,
                [](const std::string&amp; name){
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                       return &quot;Hi &quot; + name + &quot;, I&#39;m an example doing some work at &quot; +
                       timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
               }, std::to_string(i))
        );
    }
    // wait until all are ready
    do {
        for (auto &amp;future : futures) {
            if (isReady(future)) {
                readyFutures.push_back(future.get());
            }
        }
    } while (readyFutures.size() &lt; futures.size());

    for (const auto&amp; result : readyFutures) {
        std::cout &lt;&lt; result &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>I&#39;m explicitly using parameters in the lambda to show what is being passed
around. If you don&#39;t like lambda&#39;s you can also use variadic arguments to call
another function:</p>

<pre><code>std::string ExampleJob(int tally) {
    return &quot;Hi &quot; + std::to_string(tally) + &quot;, I&#39;m an example doing some work at &quot; + timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
}
// main {}
    futures.push_back(std::async(std::launch::async, ExampleJob, i));
</code></pre>

<p>If you create a <code>std::async</code> this way and want to pass a parameter by
reference, you need to use <code>std::ref()</code> (<a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">read why here</a>). So if you want to
pass a reference  to a string (<code>const std::string&amp; myString</code>), you would do
<code>std::async(std::launch::async, ExampleJob, std::ref(myString))</code>. </p>

<p>The above code results in the below output:</p>

<p><img src="/s/inc/img/cpp-async-3.png" alt="async example 1"></p>

<p>I&#39;ve added a helper function to print a time string. In this example all the &quot;jobs&quot;
run at the same time, but in the next example you should see a delay there. </p>

<p>This example is useful if you have a set number of items you need to work with, or
if you want the implementation to manage all the threads for you. On my workstation
I can queue up 1500 of these example jobs and they all run the same second. 15000 jobs
take 10 seconds to give you an idea.</p>

<h3 id="toc_3">Job queue with a concurrency limit</h3>

<p>This is what you probably came here for so lets get into this job queue with a
concurrency limit. We&#39;re using a <code>std::condition_variable</code> to do all the hard
work for us. Quoting <a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference</a>:</p>

<p>The <code>condition_variable</code> class is a synchronization primitive that
can be used to block a thread, or multiple threads at the same time, until
another thread both modifies a shared variable (the condition), and notifies
the <code>condition_variable</code>.</p>

<p>The purpose of a <code>std::condition_variable</code> is to wait for some
condition to become true. This is important, because you actually do need that
condition to check for <a href="http://web.archive.org/web/20210109071845/https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables">lost wakeups and spurious wakeups</a>. </p>

<p>We could also have used a polling loop to implement this waiting, but that would
use <a href="http://web.archive.org/web/20210109072438/https://stackoverflow.com/questions/16350473/why-do-i-need-stdcondition-variable/16350623">way more resources</a> than this, and would probably be more error prone.</p>

<p>How to use the <code>condition_variable</code> is almost spelled out to us on <a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference</a>,
so do go read that. If you&#39;re wondering about the technical details behind using
a <code>unique_lock</code>, <a href="http://web.archive.org/web/20210109072627/https://stackoverflow.com/questions/13099660/c11-why-does-stdcondition-variable-use-stdunique-lock/13102893">this stackoverflow post</a> has the best explanation.</p>

<p>Now onto the code. The first class, the <code>Semafoor</code> (Dommel reference here) does the
actual work, <code>count</code> is it&#39;s max limit of concurrent threads. The second class,
<code>CriticalSection</code>, is a handy dandy <code>RAII</code> wrapper. In its constructor it 
waits for the <code>Semafoor</code> (which in turn, when possible, acquires the lock) and
in its destructor it releases the <code>Semafoor</code> (which in turn, releases the lock). </p>

<p>See the last part of this article for a C++ 17 feature, the <code>std::scoped_lock</code> 
which replaces our <code>CriticalSection</code>. </p>

<p>That translates to, as long as your scope is correct, you never forget to lock or 
unlock the <code>Semafoor</code>. </p>

<pre><code>// main.cpp
class Semafoor {
public:
    explicit Semafoor(size_t count) : count(count) {}
    size_t getCount() const { return count; };     
    void lock() { // call before critical section
        std::unique_lock&lt;std::mutex&gt; lock(mutex);
        condition_variable.wait(lock, [this] {
          if (count != 0) // written out for clarity, could just be return (count != 0);
              return true;
          else
              return false;
        });
        --count;
    }
    void unlock() {  // call after critical section
        std::unique_lock&lt;std::mutex&gt; lock(mutex);
        ++count;
        condition_variable.notify_one();
    }

private:
    std::mutex mutex;
    std::condition_variable condition_variable;
    size_t count;
};

// RAII wrapper, make on of these in your &#39;work-doing&#39; class to
// lock the critical section. once it goes out of scope the
// critical section is unlocked
// Note: If you can use C++ 17, use a std::scoped_lock(SemafoorRef) 
//       instead of this class
class CriticalSection {
public:
    explicit CriticalSection(Semafoor &amp;s) : semafoor{s} {
        semafoor.lock();
    }
    ~CriticalSection() {
        semafoor.unlock();
    }
private:
    Semafoor &amp;semafoor;
};

template&lt;typename T&gt;
bool isReady(const std::future&lt;T&gt;&amp; f) {
    if (f.valid()) { // otherwise you might get an exception (std::future_error: No associated state)
        return f.wait_for(std::chrono::seconds(0)) == std::future_status::ready;
    } else {
        return false;
    }
}
std::string timeString(std::chrono::system_clock::time_point t, const std::string&amp; format) {
    time_t timepoint_time_t = std::chrono::system_clock::to_time_t(t);
    char buffer[1024];
    struct tm tm {0};
    if (!gmtime_r(&amp;timepoint_time_t, &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    if (!std::strftime(buffer, sizeof(buffer), format.c_str(), &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    return std::string{buffer};
}


int main() {
    int totalJobs = 15;
    std::vector&lt;std::future&lt;std::string&gt;&gt; futures;
    std::vector&lt;std::string&gt; readyFutures;
    Semafoor maxConcurrentJobs(3);

    // Queue up all the items,
    for (int i = 0; i &lt; totalJobs; ++i) {
        futures.push_back(
            std::async(std::launch::async,
               [](const std::string&amp; name, Semafoor&amp; maxJobs){
                 CriticalSection w(maxJobs);
                 std::this_thread::sleep_for(std::chrono::seconds(1));
                 return &quot;Hi &quot; + name + &quot;, I&#39;m an example doing some work at &quot; +
                        timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
               }, std::to_string(i), std::ref(maxConcurrentJobs))
        );
    }
    // wait until all are ready
    do {
        for (auto &amp;future : futures) {
            if (isReady(future)) {
                readyFutures.push_back(future.get());
            }
        }
    } while (readyFutures.size() &lt; futures.size());

    for (const auto&amp; result : readyFutures) {
        std::cout &lt;&lt; result &lt;&lt; std::endl;
    }
}
</code></pre>

<p>In <code>main()</code> not much has changed. I&#39;m again explicitly using parameters in the
lambda to show what is being passed around. We create a <code>Semafoor</code> with a
concurrent limit of 3, pass <a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">a reference</a> to that into the lambda, and,
most important, when our work starts we create a <code>CriticalSection</code> object,
that acquires the  <code>Semafoor</code> or waits until it is available. When that goes
out of scope, the <code>Semafoor</code> is released.</p>

<p>If you use this code, you can put your own critical section in <code>{}</code> (curly brackets) to limit that scope:</p>

<pre><code>some();
code();
{ // scope starts
    CriticalSection w(SemafoorRef); // Semafoor acquired
    do();
    work();
} // scope ends there, Semafoor released
more();
code();
</code></pre>

<p>If you don&#39;t want to use a lambda you can pass a function when creating the
<code>std::future</code>, but the <code>Semafoor</code>  has to be a reference (they all must use
the same <code>Semafoor</code>), thus we <a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">need to pass a</a> <code>std::ref()</code>, like so:</p>

<pre><code>std::string exampleJob(int tally, Semafoor&amp; maxJobs) {
    CriticalSection w(maxJobs);
    std::this_thread::sleep_for( std::chrono::seconds(1));
    return &quot;Hi &quot; + std::to_string(tally) + &quot;, I&#39;m an example doing some work at &quot; + timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
}
[...]
futures.push_back(std::async(std::launch::async, exampleJob, i, std::ref(maxConcurrentJobs)));
</code></pre>

<p>The code outputs the following:</p>

<p><img src="/s/inc/img/cpp-async-4.png" alt="code screenshot"></p>

<p>As you can see, the timestamps now have a second between them each 3 jobs,
just as we said. The <code>Semafoor</code> has a max concurrency limit of 3, which the
code and output reflect. Only 3 jobs are running at the same time. You must
make sure to use the same semaphore everywhere, otherwise you&#39;ll be copying
one and each instance has their own unique semaphore, which is  exactly not
what we want. </p>

<p>For jobs where you do need some parallelism but need more control than
<code>std::async</code> provides you, whilst not having to result to manual threads,
using this semaphore construction gives you  just enough control. In the case
of my HTTP requests, I didn&#39;t overload the server but  limited the requests to
15, but you can think of many more use cases (converting files, database 
actions, you name it).</p>

<h3 id="toc_4">C++ 17 with a scoped_lock</h3>

<p>Soon after publishing this article I got a great email from <a href="http://www.tuncan.uk">Chris Tuncan</a>
discussing  premature optimization and a new feature in C++ 17, the
<code>std::scoped_lock</code> (<a href="https://en.cppreference.com/w/cpp/thread/scoped_lock">cppreference</a>). </p>

<p>The <code>scoped_lock</code> basically replaces the <code>CriticalSection</code> class, as long as
the <code>Semafoor</code>  <a href="https://en.cppreference.com/w/cpp/named_req/BasicLockable">implements the minimal characteristics</a> of the Named
Requirement <code>BasicLockable</code>,  <code>.lock()</code> and <code>.unlock()</code>. </p>

<p>It has one more  advantage, it has a variadic constructor taking more than one
mutex. This allows it to lock multiple mutexes in a deadlock avoiding way. But
since we&#39;re only using one mutex, that&#39;s not applicable to us. Still wanted to
mention it since it is great to have that in the standard library.</p>

<p>If you are using C++ 17 you can omit the <code>CriticalSection</code> class and replace all
usage by a scoped lock. In the above example you would replace this line:</p>

<pre><code>CriticalSection w(maxJobs);
</code></pre>

<p>by this:</p>

<pre><code>std::scoped_lock w(maxJobs);
</code></pre>

<p>Also you must update the C++ standard to 17 in your <code>CMakeLists.txt</code>:</p>

<pre><code>set(CMAKE_CXX_STANDARD 17)
</code></pre>

<p>That&#39;s all there is to it. You get the advantage of using multiple mutexes if
you ever need it, and as we all know, the best code is the code you can delete
easily later on, so go ahead and replace that <code>CriticalSection</code> by a
<code>std::scoped_lock</code>. Or, if you&#39;re  not lucky enough to have a modern compiler
like most of us, go cry in a corner on all the cool language stuff you&#39;re
missing out on...</p>

<h4 id="toc_5">More comments from Chris</h4>

<p>Quoting Chris on the premature optimization, he responds to my statement in the opening
paragraph <code>On linux/gcc it will probably use a thread pool...</code>. </p>

<blockquote>
<p>If we cannot assume the implementation uses a thread pool, and instead
spawns a thread per <code>std:async</code> call, AND if you intent is to prevent lots of
threads being launched, then we would need to add an extra layer of
complexity. Currently <code>std::async</code> is called <code>totalJobs</code> times, with or
without the semaphore. Just with the <code>Semafoor</code> all but <code>maxJobs</code> of those
threads would go to sleep. We&#39;d end up needing some sort of queue of jobs to
pass to <code>std::async</code>, any you&#39;d need to wrap <code>async</code> so you don&#39;t have to
block created <code>async jobs</code>, and ..., and ....</p>

<p>Eurgh, that ruins all the simplicity of your solution, and is definitely a
case of premature optimisation!</p>
</blockquote>

<p>I agree with both points. Easy for me to assume GCC, but premature
optimization is also a pitfall. For this articles purpose, the problem is not
spawning too many threads but overloading the computer or remote server
(either hundreds of concurrent requests or turning your computer into a <a href="https://xkcd.com/1172/">space
heater</a> when converting a million photos at the same time).</p>

<p>Thank you to Chris for both points of feedback and the code examples. I&#39;d not yet 
worked with Named Requirements explicitly, exploring them will be fun.</p>
Tags: <a href="../tags/async.html">async</a>
, <a href="../tags/c++.html">c++</a>
, <a href="../tags/cmake.html">cmake</a>
, <a href="../tags/cpp.html">cpp</a>
, <a href="../tags/development.html">development</a>
, <a href="../tags/mutex.html">mutex</a>
, <a href="../tags/semaphore.html">semaphore</a>
, <a href="../tags/threads.html">threads</a>
, <a href="../tags/tutorials.html">tutorials</a>
</div></main>
<br/>
<footer>
<br>
                <p><small>
                <a href="/s/">Home</a> | 
                <a href="/s/static/About.html">About</a> | 
                <a href="/s/tags/all.html">All pages</a> | 
                <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                Generated by <a href="/s/software/ingsoc.html">ingsoc</a>.</small>
                </p>
    
    </footer>
    <script data-goatcounter="https://raymii.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>

    <script defer src="/s/inc/js/instant.5.2.0.js"  type="module" ></script>

     
    </main>
    </body>
    </html>
    