<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <?xml-stylesheet href="/s/inc/rss.xsl" type="text/xsl"?>
    <rss version="2.0"  xmlns:atom="http://www.w3.org/2005/Atom">
        <channel>
            <title>RSS feed for tag mosquitto on Raymii.org</title> 
            <link>https://raymii.org/s/tags/mosquitto.xml</link> 
            <description>RSS feed for tag mosquitto on Raymii.org</description>
            <atom:link href="https://raymii.org/s/tags/mosquitto.xml" rel="self" type="application/rss+xml" />
    
            <item>
                <title>High Available Mosquitto MQTT on Kubernetes</title> 
                <link>https://raymii.org/s/tutorials/High_Available_Mosquitto_MQTT_Broker_on_Kubernetes.html?utm_medium=rss&amp;utm_source=raymii&amp;utm_campaign=tagrss</link> 
                <guid>https://raymii.org/s/tutorials/High_Available_Mosquitto_MQTT_Broker_on_Kubernetes.html</guid>
                <description>In this post, we'll walk through a fully declarative, Kubernetes-native setup for running a highly available MQTT broker using Eclipse Mosquitto. This configuration leverages core Kubernetes primitives (`Deployments`, `Services`, `ConfigMaps`, and `RBAC`), alongside Traefik `IngressRouteTCP` to expose MQTT traffic externally. It introduces a lightweight, self-healing failover mechanism that automatically reroutes traffic to a secondary broker if the primary becomes unhealthy. The setup also demonstrates internal MQTT bridging, allowing seamless message propagation between brokers. The big advantage over a single Pod deployment (which, in case of node failure, k8s will restart after 5 minutes) is that this setup has a downtime of only 5 seconds and shared state, so all messages will be available on a failover.</description> 
                <pubDate>Wed, 14 May 2025 22:11:00 GMT</pubDate>
                <lastBuildDate>Wed, 14 May 2025 22:11:00 GMT</lastBuildDate>
            </item>
    
        </channel>
    </rss>
    
    