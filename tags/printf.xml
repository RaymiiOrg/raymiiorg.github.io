<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <?xml-stylesheet href="/s/inc/rss.xsl" type="text/xsl"?>
    <rss version="2.0"  xmlns:atom="http://www.w3.org/2005/Atom">
        <channel>
            <title>RSS feed for tag printf on Raymii.org</title> 
            <link>https://raymii.org/s/tags/printf.xml</link> 
            <description>RSS feed for tag printf on Raymii.org</description>
            <atom:link href="https://raymii.org/s/tags/printf.xml" rel="self" type="application/rss+xml" />
    
            <item>
                <title>Rectangle{} debugging in QML, just like printf(), but for QT</title> 
                <link>https://raymii.org/s/articles/Rectangle_debugging_in_QML_just_like_printf.html?utm_medium=rss&amp;utm_source=raymii&amp;utm_campaign=tagrss</link> 
                <guid>https://raymii.org/s/articles/Rectangle_debugging_in_QML_just_like_printf.html</guid>
                <description>Recently I've been using a debugging technique in QT/QML that I've decided to name `Rectangle{}` debugging, in the same vein as `printf()` debugging. QML is a markup language (part of the QT framework) like HTML/CSS, with inline Javascript that can interact with the C++ code of your (QT) application. QML has the concept of `anchors` for relative positioning of elements. Overall, `anchors` work quite well, but can get complex when inheretance and complicated layouts come into play. The `Rectangle{}` style of debugging places a semi-transparent rectangle with a border around your element so you can visualize the positioning and see what effect your changes have. This article shows an example where I recently applied this style of debugging at work in our coffee machine user interface, including some tips to do actual `printf()` style debugging (but with `Console.log`).</description> 
                <pubDate>Wed, 08 Sep 2021 00:00:00 GMT</pubDate>
                <lastBuildDate>Wed, 08 Sep 2021 00:00:00 GMT</lastBuildDate>
            </item>
    
            <item>
                <title>Execute a command and get both output and exit status in C++ (Windows &amp; Linux)</title> 
                <link>https://raymii.org/s/articles/Execute_a_command_and_get_both_output_and_exit_code.html?utm_medium=rss&amp;utm_source=raymii&amp;utm_campaign=tagrss</link> 
                <guid>https://raymii.org/s/articles/Execute_a_command_and_get_both_output_and_exit_code.html</guid>
                <description>Recently I had to parse some command line output inside a C++ program. Executing a command and getting just the exit status is easy using `std::system`, but  also getting output is a bit harder and OS specific. By using `popen`, a POSIX `C` function we can get both the exit status as well as the output of a given command. On Windows I'm using `_popen`, so the code should be cross platform, except for the exit status on Windows is alway 0, that concept does not exist there. This article starts off with a stack overflow example to  get just the output of a command and builds on that to a safer version (null-byte handling) that returns both the exit status as well as the command output. It also involves a lot of detail on `fread` vs `fgets` and how to handle binary data.</description> 
                <pubDate>Mon, 07 Jun 2021 00:00:00 GMT</pubDate>
                <lastBuildDate>Mon, 07 Jun 2021 00:00:00 GMT</lastBuildDate>
            </item>
    
            <item>
                <title>Three ways to print booleans as 'True' or 'False' in C++</title> 
                <link>https://raymii.org/s/articles/Print_booleans_as_True_or_False_in_C++.html?utm_medium=rss&amp;utm_source=raymii&amp;utm_campaign=tagrss</link> 
                <guid>https://raymii.org/s/articles/Print_booleans_as_True_or_False_in_C++.html</guid>
                <description>In this article I'll show you three ways to print a textual representation of a boolean in C++. Normally a bool is printed as either a `0` or a `1` by `std::cout`, but more often than not, if you're printing a `bool`, it's better to see `true/false`. Imagine reading through lines and lines of boring, repeating log files, how easy is it to miss a `0` in a sea of `1`'s? I've been there many times, wishing for more verbose logs.
I'll start with a simple `printf` with a ternary `if`  e.g. `(a ? this : that)` and continue on to `std::boolalpha`. The latter one is more flexible and allows you to set different values to be printed, for localization,  and can even be used to parse input streams. That means, the string `true false` results in two `booleans`, the first being, well, `true` and the latter, surprisingly, being `false`.</description> 
                <pubDate>Sun, 21 Mar 2021 00:00:00 GMT</pubDate>
                <lastBuildDate>Sun, 21 Mar 2021 00:00:00 GMT</lastBuildDate>
            </item>
    
        </channel>
    </rss>
    
    